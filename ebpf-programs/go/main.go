package main

import (
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

// Constants for the eBPF program and network interface
const (
	xdpProgPath = "abnormal_traffic.o"
	iface       = "eth0"
)

// Anomaly event generated by eBPF program
type AnomalyEvent struct {
	Ts       uint64
	SrcIP    uint32
	DestIP   uint32
	SrcPort  uint16
	DestPort uint16
}

func main() {
	// Remove memory lock limit
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Failed to remove memlock limit: %v", err)
	}

	// Load compiled eBPF program
	spec, err := ebpf.LoadCollectionSpec(xdpProgPath)
	if err != nil {
		log.Fatalf("Failed to load eBPF program: %v", err)
	}

	// Create new eBPF collection
	coll := new(ebpf.Collection)
	if err := spec.LoadAndAssign(coll, nil); err != nil {
		log.Fatalf("Failed to load and assign eBPF program: %v", err)
	}
	defer coll.Close()

	// Attach eBPF program to specified network interface
	xdpProg := coll.Programs["xdp_prog_simple"]
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   xdpProg,
		Interface: iface,
	})
	if err != nil {
		log.Fatalf("Failed to attach eBPF program to interface %s: %v", iface, err)
	}
	defer l.Close()

	log.Printf("eBPF program successfully attached to interface %s", iface)

	// Set up perf event reader to read events
	rd, err := ebpf.NewPerfEventReader(coll.Maps["events"], os.Getpagesize())
	if err != nil {
		log.Fatalf("Failed to create perf event reader: %v", err)
	}
	defer rd.Close()

	// Channel to receive OS signals for graceful termination
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

	// Goroutine to read events from the perf event reader
	go func() {
		for {
			// Read a perf event record
			record, err := rd.Read()
			if err != nil {
				log.Printf("Error reading from perf event reader: %v", err)
				continue
			}

			// Check for lost samples
			if record.LostSamples != 0 {
				log.Printf("Perf event ring buffer full, dropped %d samples", record.LostSamples)
				continue
			}

			// Unmarshal the event data into an AnomalyEvent structure
			var event AnomalyEvent
			if err := event.UnmarshalBinary(record.RawSample); err != nil {
				log.Printf("Error unmarshalling perf event: %v", err)
				continue
			}

			// Log the detected anomaly
			log.Printf("Anomaly detected: %+v", event)
		}
	}()

	// Wait for termination signal
	<-sig
	log.Println("Detaching eBPF program and exiting...")
}

// UnmarshalBinary unmarshals binary data into an AnomalyEvent structure
func (e *AnomalyEvent) UnmarshalBinary(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("too short for AnomalyEvent: %d bytes", len(data))
	}
	e.Ts = binary.LittleEndian.Uint64(data[0:8])
	e.SrcIP = binary.LittleEndian.Uint32(data[8:12])
	e.DestIP = binary.LittleEndian.Uint32(data[12:16])
	e.SrcPort = binary.LittleEndian.Uint16(data[16:18])
	e.DestPort = binary.LittleEndian.Uint16(data[18:20])
	return nil
}
